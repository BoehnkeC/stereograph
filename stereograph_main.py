# -*- coding: utf-8 -*-
"""
/***************************************************************************
 StereographDockWidget
                                 A QGIS plugin
 This plugin plots structural geological data.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Christian BÃ¶hnke
        email                : christian@home-boehnke.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
import copy
from pathlib import Path

from qgis.PyQt import uic
from PyQt5 import QtCore, QtGui, QtWidgets
from qgis.PyQt.QtCore import pyqtSignal
from PyQt5.QtCore import Qt
from qgis.core import QgsProject, QgsMapLayerType, QgsFeatureRequest
from .options import Types, TypesIndices, FormatsShort, FormatsLong

# import matplotlibs backend for plotting in PyQT5
# see https://www.geeksforgeeks.org/how-to-embed-matplotlib-graph-in-pyqt5/
from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar

from copy import deepcopy

from .stereograph_input import StereoGraphInputWidget

# from stereograph_plot_settings import StereoGraphPltSettingsWidget

# APSG library by Ondro Lexa: https://github.com/ondrolexa/apsg
try:
    from apsg import *

except ImportError:
    mod_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "mod", "apsg-0.7.0-py2.py3-none-any.whl")
    sys.path.append(mod_path)
    from apsg import *

FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "stereograph_gui.ui")
)


class StereographDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(StereographDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        #self.stereonet = StereoNet()
        self.layers = Layers()
        self.removable_layer = None
        self.formats = None
        self.format_selection = None

        # this is the Canvas Widget that
        # displays the 'figure'it takes the
        # 'figure' instance as a parameter to __init__
        #self.canvas = FigureCanvas(self.stereonet.fig)

        # this is the Navigation widget
        # it takes the Canvas widget and a parent
        #self.toolbar = NavigationToolbar(self.canvas, self)

        # adding tool bar to the layout
        #self.plot_layout.addWidget(self.toolbar)

        # adding canvas to the layout
        #self.plot_layout.addWidget(self.canvas)

        self.survey_layers()  # get layers loaded in QGIS
        self.init_dataset_combobox()  # insert layers in dataset combobox
        self.init_types_and_formats()

        self.cmb_set.currentIndexChanged.connect(self.store_layer)
        self.cmb_type.currentIndexChanged.connect(self.store_type)
        self.cmb_format.currentIndexChanged.connect(self.store_format)

    def survey_layers(self):
        for layer in QgsProject.instance().mapLayers().items():
            # layer is a tuple, e.g. ('lines_dfb84f76_7835_4663_8da0_d43d8c1620f7', <QgsMapLayer: 'lines' (ogr)>)
            if layer[1].type() == QgsMapLayerType.VectorLayer:
                self.layers.add_layer(Layer(layer[1]))

    def init_dataset_combobox(self):
        self.cmb_set.clear()

        if len(self.layers.layer_list) > 0:
            self.cmb_set.addItem("Deselect")
            self.cmb_set.addItems([layer.name for layer in self.layers.layer_list])

    def init_types_and_formats(self):
        """
        Get all entries back to default.
        Clear data table.
        """

        self.cmb_type.clear()
        self.cmb_type.addItems([_type.value for _type in Types])

        self.init_format_combobox()  # nothing selected yet, fill formats with dummy entry

        self.tbl_input.setRowCount(0)
        self.tbl_input.setHorizontalHeaderLabels(["", "", ""])

    def init_format_combobox(self):
        """
        Fill format combobox based on type selection.
        Changes everytime the type selection changes.
        """

        self.cmb_format.clear()

        if self.cmb_type.currentIndex() == TypesIndices.dummy:
            self.cmb_format.addItem("Please select dataset type.")

        elif self.cmb_type.currentIndex() == TypesIndices.lines:
            self.cmb_format.addItems([_line.value for _line in FormatsShort.Lines])
            self.formats = [_line.value for _line in FormatsLong.Lines]

        elif self.cmb_type.currentIndex() == TypesIndices.planes:
            self.cmb_format.addItems([_plane.value for _plane in FormatsShort.Planes])
            self.formats = [_plane.value for _plane in FormatsLong.Planes]

        else:
            raise AttributeError("The selected type and format and not implemented.")

    def get_layer_from_combobox(self):
        if self.cmb_set.currentIndex() > 0:
            return self.layers.layer_list[self.cmb_set.currentIndex() - 1]

    def store_layer(self):
        """
        There has been a selection in the dataset combobox. Check if the vector has been selected before.
        If not, store the selection data in the Layer class.
        If selected before, reload the selection data from the Layer class.
        """
        layer = self.get_layer_from_combobox()  # get layer from dataset combobox

        if layer is not None:  # active layer selection
            if layer.set_index is None:  # layer not stored yet
                layer.set_index = self.cmb_set.currentIndex()
                self.init_types_and_formats()
                layer.type_index = None
                layer.format_index = None

            else:  # layer already stored
                if layer.type_index is not None:  # type already stored
                    self.cmb_type.setCurrentIndex(layer.type_index)  # set type combobox to type index

                    if layer.format_index is not None:  # format index already stored
                        self.handle_format(layer)

                    else:
                        self.init_format_combobox()  # format not stored yet

                else:
                    self.cmb_type.setCurrentIndex(0)  # type not stored yet

        else:  # index of dataset combobox is 0, get back to default setup
            self.init_types_and_formats()

    def store_type(self):
        layer = self.get_layer_from_combobox()  # get vector layer

        if layer is not None:
            if self.cmb_type.currentIndex() > 0:  # store type if not dummy entry
                layer.type_index = self.cmb_type.currentIndex()

                # type index changed
                # get new format index or apply old one
                self.handle_format(layer)

    def handle_format(self, layer):
        """
        Index of format combobox changes everytime when type index changes.
        This also applies when selecting another dataset which has a type.
        If the format was stored previosly, retrieve that index and apply it to the new index.
        If the format has not been stored previosly, the new index will not be overwritten.
        """

        if layer.format_index is not None:  # format already stored
            layer.format_index_tmp = copy.deepcopy(layer.format_index)  # store backup of format index

        self.init_format_combobox()  # triggers self.store_format and new layer.format_index

        if layer.format_index_tmp is not None:  # format previosly stored
            self.cmb_format.setCurrentIndex(layer.format_index_tmp)  # set format index to previously stored index
            layer.format_index_tmp = None

        self.fill_data_table()

    def store_format(self):
        """
        This function is called whenever the index of the format combobox changes.
        The index changes everytime the type index changes.
        If the type index changes, this function is triggered and the format index will be set to 0 automatically
        as the format combobox is freshly filled.
        If the format index has been stored previosly, the aforementioned behavior can be resolved by saving a backup
        of the format index and applying it to the format combobox after it has been filled.
        """

        layer = self.get_layer_from_combobox()

        if layer is not None:  # layer already stored
            layer.format_index = self.cmb_format.currentIndex()  # get a new format index

            # hacky workaround because signal can be emitted 3 times with self.formats = None even though it should be filled already
            if self.formats is not None:
                self.fill_data_table()

    def fill_data_table(self):
        layer = self.get_layer_from_combobox()

        if layer is not None:  # layer already stored
            if layer.set_index is not None and layer.type_index is not None and layer.format_index is not None:
                self.format_selection = self.formats[layer.format_index]  # slice list at current index of format combobox

                # set header of input table
                self.tbl_input.setHorizontalHeaderLabels(["ID", self.format_selection[0], self.format_selection[1]])

                self.tbl_input.setRowCount(
                    self.layers.layer_list[self.cmb_set.currentIndex()-1].layer.featureCount()
                )

                for row in range(self.tbl_input.rowCount()):
                    feature = self.layers.layer_list[self.cmb_set.currentIndex()-1].layer.getFeature(row)

                    # set id
                    if feature.attributes()[0]:
                        fid = feature.attributes()[0]

                    else:
                        fid = feature.id()

                    col_0 = QtWidgets.QTableWidgetItem()
                    col_1 = QtWidgets.QTableWidgetItem()
                    col_2 = QtWidgets.QTableWidgetItem()

                    col_0.setData(Qt.EditRole, fid)
                    #col_1.setData(Qt.EditRole, feature.attributes()[self.layers.layer_list[layer.set_index].index_field_0])
                    #col_2.setData(Qt.EditRole, feature.attributes()[self.layers.layer_list[index].index_field_1])

                    self.tbl_input.setItem(row, 0, col_0)
                    #self.tbl_input.setItem(row, 1, col_1)
                    #self.tbl_input.setItem(row, 2, col_2)

        else:  # index of dataset combobox is 0, get back to default setup
            self.cmb_type.setCurrentIndex(0)
            self.cmb_format.setCurrentIndex(0)

            self.tbl_input.setRowCount(0)
            self.tbl_input.setHorizontalHeaderLabels(["", "", ""])


class Layers:
    def __init__(self):
        self.layer_list = []

    def add_layer(self, layer):
        self.layer_list.append(layer)

    def remove_layer(self, layer):
        self.layer_list.remove(layer)


class Layer:
    def __init__(self, layer=None):
        # self.layer = QgsProject.instance().mapLayers()[layer.layer_id]
        self.layer_id = layer.id()
        self.layer = layer  # QGIS vlayer
        self.name = layer.name()
        self.set_index = None
        self.type_index = None
        self.format_index = None
        self.format_index_tmp = None  # backup of format index as format_index may be overwritten
