# -*- coding: utf-8 -*-
"""
/***************************************************************************
 StereographDockWidget
                                 A QGIS plugin
 This plugin plots structural geological data.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-04-12
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Christian BÃ¶hnke
        email                : christian@home-boehnke.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
import copy
from pathlib import Path

from qgis.PyQt import uic
from PyQt5 import QtCore, QtGui, QtWidgets
from qgis.PyQt.QtCore import pyqtSignal
from PyQt5.QtCore import Qt
from qgis.core import QgsProject, QgsMapLayerType, QgsFeatureRequest
from .options import Types, TypesIndices, FormatsShort, Formats, Lines, Planes

# import matplotlibs backend for plotting in PyQT5
# see https://www.geeksforgeeks.org/how-to-embed-matplotlib-graph-in-pyqt5/
from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar

from copy import deepcopy

from .options import *
from .stereograph_input import StereoGraphInputWidget

# from stereograph_plot_settings import StereoGraphPltSettingsWidget

# APSG library by Ondro Lexa: https://github.com/ondrolexa/apsg
try:
    from apsg import *

except ImportError:
    mod_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "mod", "apsg-0.7.0-py2.py3-none-any.whl")
    sys.path.append(mod_path)
    from apsg import *

FORM_CLASS, _ = uic.loadUiType(
    os.path.join(os.path.dirname(__file__), "stereograph_gui.ui")
)


class StereographDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(StereographDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # self.stereonet = StereoNet()
        self.layers = Layers()
        self.removable_layer = None
        self.types_values = None
        self.formats_values = None
        self.format_selection = None
        self.fields = None

        # this is the Canvas Widget that
        # displays the 'figure'it takes the
        # 'figure' instance as a parameter to __init__
        # self.canvas = FigureCanvas(self.stereonet.fig)

        # this is the Navigation widget
        # it takes the Canvas widget and a parent
        # self.toolbar = NavigationToolbar(self.canvas, self)

        # adding tool bar to the layout
        # self.plot_layout.addWidget(self.toolbar)

        # adding canvas to the layout
        # self.plot_layout.addWidget(self.canvas)

        self.survey_layers()  # get layers loaded in QGIS
        self.init_dataset_combobox()  # insert layers in dataset combobox
        # self.init_types_formats_and_fields()

        self.cmb_set.currentIndexChanged.connect(self.store_layer)
        # self.cmb_set.currentIndexChanged.connect(self.init_types_combobox)
        self.cmb_type.currentIndexChanged.connect(self.store_type)
        self.cmb_format.currentIndexChanged.connect(self.store_format)
        # self.cmb_field0.currentIndexChanged.connect(lambda: self.store_fields(item=self.cmb_field0))
        # self.cmb_field1.currentIndexChanged.connect(lambda: self.store_fields(item=self.cmb_field1))

    def survey_layers(self):
        """
        Finds layers in QGIS TOC and add to internal class.
        """
        for layer in QgsProject.instance().mapLayers().items():
            # layer is a tuple, e.g. ('lines_dfb84f76_7835_4663_8da0_d43d8c1620f7', <QgsMapLayer: 'lines' (ogr)>)
            if layer[1].type() == QgsMapLayerType.VectorLayer:
                self.layers.add_layer(Layer(layer[1]))

    def get_layer_from_combobox(self):
        return self.layers.layer_list[self.cmb_set.currentIndex() - 1]

    def init_dataset_combobox(self):
        self.cmb_set.clear()  # does not trigger self.store_layer

        if len(self.layers.layer_list) > 0:
            self.cmb_set.addItem("Deselect")
            self.cmb_set.addItems([layer.name for layer in self.layers.layer_list])

    def init_types_combobox(self, layer=None):
        self.cmb_type.clear()
        # self.cmb_format.clear()

        types = list(Types.__dict__[
                         "_member_map_"].keys())  # _member_map: OrderedDict([('dummy', <Types.dummy: '--No type--'>), etc.
        self.types_values = [Types.__dict__[_type].value for _type in
                             types]  # get a list of class object values of class Types

        self.cmb_type.addItems(self.types_values)
        # self.cmb_format.addItem("Please select type")

        if layer:  # layer already stored
            if layer.type_index:  # type already stored
                self.cmb_type.setCurrentIndex(layer.type_index)

    def init_format_combobox(self, layer=None):
        # Add an initial entry saying that type has to be selected first
        # if type selected, fill combobox based on type
        self.cmb_format.clear()

        if not layer:
            self.cmb_format.addItem("--Select type--")

        if layer:  # layer already stored
            if not layer.type_index:  # no type selected yet
                self.cmb_format.addItem("--Select type--")

            if layer.type_index:  # type already stored
                if self.types_values[layer.type_index] == "Lines":
                    formats = list(Lines.__dict__[
                                       "_member_map_"].keys())  # _member_map: OrderedDict([('dummy', <Lines.dummy: '--No format--'>), etc.
                    self.formats_values = [Lines.__dict__[_format].value for _format in
                                           formats]  # get a list of class object values of class Types
                    self.cmb_format.addItems(self.formats_values)

                elif self.types_values[layer.type_index] == "Planes":
                    formats = list(Planes.__dict__[
                                       "_member_map_"].keys())  # _member_map: OrderedDict([('dummy', <Planes.dummy: '--No format--'>), etc.
                    self.formats_values = [Planes.__dict__[_format].value for _format in
                                           formats]  # get a list of class object values of class Types
                    self.cmb_format.addItems(self.formats_values)

                    # TODO: Planes index shifts when restoring the layer and shows values that have not been selected

                if layer.format_index:
                    self.cmb_format.setCurrentIndex(layer.type_index)

    @staticmethod
    def default_combobox(combobox=None, desc=None):
        combobox.clear()
        combobox.addItem(desc)

    def store_layer(self):
        """
        There has been a selection in the dataset combobox. Check if the vector has been selected before.
        If not, store the selection data in the Layer class.
        If selected before, reload the selection data from the Layer class.
        """

        if self.cmb_set.currentIndex() > 0:  # active layer selection
            layer = self.get_layer_from_combobox()  # get layer from dataset combobox
            # self.init_fields_comboboxes(layer)

            if layer.dataset_index is None:  # layer not stored yet
                print("Layer is None")
                layer.dataset_index = self.cmb_set.currentIndex()  # store combobox index
                layer.type_index = None  # all other indixes must be None
                layer.format_index = None  # all other indixes must be None
                layer.fields_indices = [None, None]  # all other indixes must be None

                self.init_types_combobox()
                self.init_format_combobox()

            else:  # layer already stored, no further action needed for dataset
                print(layer.name)

                self.init_types_combobox(layer=layer)
                self.init_format_combobox(layer=layer)

        else:  # index of dataset combobox is 0, get back to default setup
            print("Deselect")
            self.default_combobox(combobox=self.cmb_type, desc="Please select dataset.")
            # self.init_fields_comboboxes()
            pass

    def store_type(self):
        if self.cmb_type.currentIndex() > 0:
            layer = self.get_layer_from_combobox()

            if self.cmb_type.currentIndex() != layer.type_index:  # valid and new selection
                layer.type_index = self.cmb_type.currentIndex()
                self.init_format_combobox(layer=layer)  # fill format combobox

    def store_format(self):
        if self.cmb_format.currentIndex() > 0:
            layer = self.get_layer_from_combobox()

            if self.cmb_format.currentIndex() != layer.format_index:  # valid and new selection
                layer.format_index = self.cmb_format.currentIndex()


class Layers:
    def __init__(self):
        self.layer_list = []

    def add_layer(self, layer):
        self.layer_list.append(layer)

    def remove_layer(self, layer):
        self.layer_list.remove(layer)


class Layer:
    def __init__(self, layer=None):
        # self.layer = QgsProject.instance().mapLayers()[layer.layer_id]
        self.layer_id = layer.id()
        self.layer = layer  # QGIS vlayer
        self.name = layer.name()
        self.dataset_index = None
        self.type_index = None
        self.format_index = None
        self.format_index_tmp = None  # backup of format index as format_index may be overwritten
        self.fields_indices = [None, None]
        self.fields_indices_tmp = [None, None]
